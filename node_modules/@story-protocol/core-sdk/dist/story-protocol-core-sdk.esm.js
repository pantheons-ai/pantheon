import { getAddress, encodeAbiParameters, parseAbiParameters, decodeEventLog, encodeFunctionData, zeroAddress, stringToHex, createPublicClient, createWalletClient } from 'viem';
import * as dotenv from 'dotenv';
import { polygonMumbai, sepolia as sepolia$1, mainnet } from 'viem/chains';
import axios from 'axios';

function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

function handleError(error, msg) {
  if (error instanceof Error) {
    throw new Error("".concat(msg, ": ").concat(error.message));
  }
  throw new Error("".concat(msg, ": Unknown error type"));
}

var AddressZero = "0x0000000000000000000000000000000000000000";
var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
var SepoliaChainId = "11155111";

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

var IERC1155ABI = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "operator",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256[]",
    name: "ids",
    type: "uint256[]"
  }, {
    indexed: false,
    internalType: "uint256[]",
    name: "values",
    type: "uint256[]"
  }],
  name: "TransferBatch",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "operator",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "from",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "id",
    type: "uint256"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }],
  name: "TransferSingle",
  type: "event"
}];

var AccessControllerABI = [{
  anonymous: false,
  inputs: [{
    indexed: false,
    internalType: "address",
    name: "ipAccountOwner",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "ipAccount",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "signer",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    indexed: false,
    internalType: "bytes4",
    name: "func",
    type: "bytes4"
  }, {
    indexed: false,
    internalType: "uint8",
    name: "permission",
    type: "uint8"
  }],
  name: "PermissionSet",
  type: "event"
}, {
  inputs: [{
    internalType: "address",
    name: "ipAccount",
    type: "address"
  }, {
    internalType: "address",
    name: "signer",
    type: "address"
  }, {
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "bytes4",
    name: "func",
    type: "bytes4"
  }, {
    internalType: "uint8",
    name: "permission",
    type: "uint8"
  }],
  name: "setPermission",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];

var DisputeModuleABI = [{
  anonymous: false,
  inputs: [{
    indexed: false,
    internalType: "uint256",
    name: "disputeId",
    type: "uint256"
  }, {
    indexed: false,
    internalType: "bytes",
    name: "data",
    type: "bytes"
  }],
  name: "DisputeCancelled",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: false,
    internalType: "uint256",
    name: "disputeId",
    type: "uint256"
  }, {
    indexed: false,
    internalType: "address",
    name: "targetIpId",
    type: "address"
  }, {
    indexed: false,
    internalType: "address",
    name: "disputeInitiator",
    type: "address"
  }, {
    indexed: false,
    internalType: "address",
    name: "arbitrationPolicy",
    type: "address"
  }, {
    indexed: false,
    internalType: "bytes32",
    name: "linkToDisputeEvidence",
    type: "bytes32"
  }, {
    indexed: false,
    internalType: "bytes32",
    name: "targetTag",
    type: "bytes32"
  }, {
    indexed: false,
    internalType: "bytes",
    name: "data",
    type: "bytes"
  }],
  name: "DisputeRaised",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: false,
    internalType: "uint256",
    name: "disputeId",
    type: "uint256"
  }],
  name: "DisputeResolved",
  type: "event"
}, {
  inputs: [{
    internalType: "uint256",
    name: "disputeId",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "data",
    type: "bytes"
  }],
  name: "cancelDispute",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "targetIpId",
    type: "address"
  }, {
    internalType: "string",
    name: "linkToDisputeEvidence",
    type: "string"
  }, {
    internalType: "bytes32",
    name: "targetTag",
    type: "bytes32"
  }, {
    internalType: "bytes",
    name: "data",
    type: "bytes"
  }],
  name: "raiseDispute",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256",
    name: "disputeId",
    type: "uint256"
  }],
  name: "resolveDispute",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}];

var IPAccountImplABI = [{
  inputs: [{
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "data",
    type: "bytes"
  }],
  name: "execute",
  outputs: [{
    internalType: "bytes",
    name: "result",
    type: "bytes"
  }],
  stateMutability: "payable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "uint256",
    name: "value",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "data",
    type: "bytes"
  }, {
    internalType: "address",
    name: "signer",
    type: "address"
  }, {
    internalType: "uint256",
    name: "deadline",
    type: "uint256"
  }, {
    internalType: "bytes",
    name: "signature",
    type: "bytes"
  }],
  name: "executeWithSig",
  outputs: [{
    internalType: "bytes",
    name: "result",
    type: "bytes"
  }],
  stateMutability: "payable",
  type: "function"
}];

var IPAssetRegistryABI = [{
  anonymous: false,
  inputs: [{
    indexed: false,
    internalType: "address",
    name: "ipId",
    type: "address"
  }, {
    indexed: true,
    internalType: "uint256",
    name: "chainId",
    type: "uint256"
  }, {
    indexed: true,
    internalType: "address",
    name: "tokenContract",
    type: "address"
  }, {
    indexed: true,
    internalType: "uint256",
    name: "tokenId",
    type: "uint256"
  }, {
    indexed: false,
    internalType: "address",
    name: "resolver",
    type: "address"
  }, {
    indexed: false,
    internalType: "address",
    name: "provider",
    type: "address"
  }, {
    indexed: false,
    internalType: "bytes",
    name: "metadata",
    type: "bytes"
  }],
  name: "IPRegistered",
  type: "event"
}, {
  inputs: [{
    internalType: "uint256",
    name: "chainId",
    type: "uint256"
  }, {
    internalType: "address",
    name: "tokenContract",
    type: "address"
  }, {
    internalType: "uint256",
    name: "tokenId",
    type: "uint256"
  }],
  name: "ipId",
  outputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "id",
    type: "address"
  }],
  name: "isRegistered",
  outputs: [{
    internalType: "bool",
    name: "",
    type: "bool"
  }],
  stateMutability: "view",
  type: "function"
}];

var LicensingModuleABI = [{
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "caller",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "ipId",
    type: "address"
  }, {
    indexed: false,
    internalType: "address[]",
    name: "parentIpIds",
    type: "address[]"
  }],
  name: "IpIdLinkedToParents",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "address",
    name: "caller",
    type: "address"
  }, {
    indexed: true,
    internalType: "address",
    name: "ipId",
    type: "address"
  }, {
    indexed: true,
    internalType: "uint256",
    name: "policyId",
    type: "uint256"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "index",
    type: "uint256"
  }, {
    indexed: false,
    internalType: "bool",
    name: "isInherited",
    type: "bool"
  }],
  name: "PolicyAddedToIpId",
  type: "event"
}, {
  anonymous: false,
  inputs: [{
    indexed: true,
    internalType: "uint256",
    name: "policyId",
    type: "uint256"
  }, {
    indexed: true,
    internalType: "address",
    name: "policyFrameworkManager",
    type: "address"
  }, {
    indexed: false,
    internalType: "bytes",
    name: "frameworkData",
    type: "bytes"
  }, {
    indexed: false,
    internalType: "address",
    name: "royaltyPolicy",
    type: "address"
  }, {
    indexed: false,
    internalType: "bytes",
    name: "royaltyData",
    type: "bytes"
  }, {
    indexed: false,
    internalType: "uint256",
    name: "mintingFee",
    type: "uint256"
  }, {
    indexed: false,
    internalType: "address",
    name: "mintingFeeToken",
    type: "address"
  }],
  name: "PolicyRegistered",
  type: "event"
}, {
  inputs: [{
    internalType: "address",
    name: "ipId",
    type: "address"
  }, {
    internalType: "uint256",
    name: "polId",
    type: "uint256"
  }],
  name: "addPolicyToIp",
  outputs: [{
    internalType: "uint256",
    name: "indexOnIpId",
    type: "uint256"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    components: [{
      internalType: "bool",
      name: "isLicenseTransferable",
      type: "bool"
    }, {
      internalType: "address",
      name: "policyFramework",
      type: "address"
    }, {
      internalType: "bytes",
      name: "frameworkData",
      type: "bytes"
    }, {
      internalType: "address",
      name: "royaltyPolicy",
      type: "address"
    }, {
      internalType: "bytes",
      name: "royaltyData",
      type: "bytes"
    }, {
      internalType: "uint256",
      name: "mintingFee",
      type: "uint256"
    }, {
      internalType: "address",
      name: "mintingFeeToken",
      type: "address"
    }],
    internalType: "struct Licensing.Policy",
    name: "pol",
    type: "tuple"
  }],
  name: "getPolicyId",
  outputs: [{
    internalType: "uint256",
    name: "policyId",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256[]",
    name: "licenseIds",
    type: "uint256[]"
  }, {
    internalType: "address",
    name: "childIpId",
    type: "address"
  }, {
    internalType: "bytes",
    name: "royaltyContext",
    type: "bytes"
  }],
  name: "linkIpToParents",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256",
    name: "policyId",
    type: "uint256"
  }, {
    internalType: "address",
    name: "licensorIpId",
    type: "address"
  }, {
    internalType: "uint256",
    name: "amount",
    type: "uint256"
  }, {
    internalType: "address",
    name: "receiver",
    type: "address"
  }, {
    internalType: "bytes",
    name: "royaltyContext",
    type: "bytes"
  }],
  name: "mintLicense",
  outputs: [{
    internalType: "uint256",
    name: "licenseId",
    type: "uint256"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    components: [{
      internalType: "bool",
      name: "isLicenseTransferable",
      type: "bool"
    }, {
      internalType: "address",
      name: "policyFramework",
      type: "address"
    }, {
      internalType: "bytes",
      name: "frameworkData",
      type: "bytes"
    }, {
      internalType: "address",
      name: "royaltyPolicy",
      type: "address"
    }, {
      internalType: "bytes",
      name: "royaltyData",
      type: "bytes"
    }, {
      internalType: "uint256",
      name: "mintingFee",
      type: "uint256"
    }, {
      internalType: "address",
      name: "mintingFeeToken",
      type: "address"
    }],
    internalType: "struct Licensing.Policy",
    name: "pol",
    type: "tuple"
  }],
  name: "registerPolicy",
  outputs: [{
    internalType: "uint256",
    name: "policyId",
    type: "uint256"
  }],
  stateMutability: "nonpayable",
  type: "function"
}];

var PILPolicyFrameworkManagerABI = [{
  inputs: [{
    components: [{
      internalType: "bool",
      name: "transferable",
      type: "bool"
    }, {
      internalType: "address",
      name: "royaltyPolicy",
      type: "address"
    }, {
      internalType: "uint256",
      name: "mintingFee",
      type: "uint256"
    }, {
      internalType: "address",
      name: "mintingFeeToken",
      type: "address"
    }, {
      components: [{
        internalType: "bool",
        name: "attribution",
        type: "bool"
      }, {
        internalType: "bool",
        name: "commercialUse",
        type: "bool"
      }, {
        internalType: "bool",
        name: "commercialAttribution",
        type: "bool"
      }, {
        internalType: "address",
        name: "commercializerChecker",
        type: "address"
      }, {
        internalType: "bytes",
        name: "commercializerCheckerData",
        type: "bytes"
      }, {
        internalType: "uint32",
        name: "commercialRevShare",
        type: "uint32"
      }, {
        internalType: "bool",
        name: "derivativesAllowed",
        type: "bool"
      }, {
        internalType: "bool",
        name: "derivativesAttribution",
        type: "bool"
      }, {
        internalType: "bool",
        name: "derivativesApproval",
        type: "bool"
      }, {
        internalType: "bool",
        name: "derivativesReciprocal",
        type: "bool"
      }, {
        internalType: "string[]",
        name: "territories",
        type: "string[]"
      }, {
        internalType: "string[]",
        name: "distributionChannels",
        type: "string[]"
      }, {
        internalType: "string[]",
        name: "contentRestrictions",
        type: "string[]"
      }],
      internalType: "struct PILPolicy",
      name: "policy",
      type: "tuple"
    }],
    internalType: "struct RegisterPILPolicyParams",
    name: "params",
    type: "tuple"
  }],
  name: "registerPolicy",
  outputs: [{
    internalType: "uint256",
    name: "policyId",
    type: "uint256"
  }],
  stateMutability: "nonpayable",
  type: "function"
}];

var RegistrationModuleABI = [{
  inputs: [{
    internalType: "uint256[]",
    name: "licenseIds",
    type: "uint256[]"
  }, {
    internalType: "address",
    name: "tokenContract",
    type: "address"
  }, {
    internalType: "uint256",
    name: "tokenId",
    type: "uint256"
  }, {
    internalType: "string",
    name: "ipName",
    type: "string"
  }, {
    internalType: "bytes32",
    name: "contentHash",
    type: "bytes32"
  }, {
    internalType: "string",
    name: "externalURL",
    type: "string"
  }, {
    internalType: "bytes",
    name: "royaltyContext",
    type: "bytes"
  }],
  name: "registerDerivativeIp",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "uint256",
    name: "policyId",
    type: "uint256"
  }, {
    internalType: "address",
    name: "tokenContract",
    type: "address"
  }, {
    internalType: "uint256",
    name: "tokenId",
    type: "uint256"
  }, {
    internalType: "string",
    name: "ipName",
    type: "string"
  }, {
    internalType: "bytes32",
    name: "contentHash",
    type: "bytes32"
  }, {
    internalType: "string",
    name: "externalURL",
    type: "string"
  }],
  name: "registerRootIp",
  outputs: [{
    internalType: "address",
    name: "",
    type: "address"
  }],
  stateMutability: "nonpayable",
  type: "function"
}];

var ErrorsABI = [{
  inputs: [{
    internalType: "address",
    name: "caller",
    type: "address"
  }],
  name: "AccessControlled__CallerIsNotIpAccount",
  type: "error"
}, {
  inputs: [{
    internalType: "address",
    name: "ipAccount",
    type: "address"
  }],
  name: "AccessControlled__NotIpAccount",
  type: "error"
}, {
  inputs: [],
  name: "AccessControlled__ZeroAddress",
  type: "error"
}, {
  inputs: [],
  name: "AccessController__CallerIsNotIPAccount",
  type: "error"
}, {
  inputs: [{
    internalType: "address",
    name: "ipAccount",
    type: "address"
  }],
  name: "AccessController__IPAccountIsNotValid",
  type: "error"
}, {
  inputs: [],
  name: "AccessController__IPAccountIsZeroAddress",
  type: "error"
}, {
  inputs: [{
    internalType: "address",
    name: "ipAccount",
    type: "address"
  }, {
    internalType: "address",
    name: "signer",
    type: "address"
  }, {
    internalType: "address",
    name: "to",
    type: "address"
  }, {
    internalType: "bytes4",
    name: "func",
    type: "bytes4"
  }],
  name: "AccessController__PermissionDenied",
  type: "error"
}, {
  inputs: [],
  name: "AccessController__PermissionIsNotValid",
  type: "error"
}, {
  inputs: [{
    internalType: "address",
    name: "to",
    type: "address"
  }],
  name: "AccessController__RecipientIsNotRegisteredModule",
  type: "error"
}, {
  inputs: [],
  name: "AccessController__SignerIsZeroAddress",
  type: "error"
}, {
  inputs: [],
  name: "AncestorsVaultLAP__AlreadyClaimed",
  type: "error"
}, {
  inputs: [],
  name: "AncestorsVaultLAP__ClaimerNotAnAncestor",
  type: "error"
}, {
  inputs: [],
  name: "AncestorsVaultLAP__ERC20BalanceNotZero",
  type: "error"
}, {
  inputs: [],
  name: "AncestorsVaultLAP__ETHBalanceNotZero",
  type: "error"
}, {
  inputs: [],
  name: "AncestorsVaultLAP__InvalidAncestorsHash",
  type: "error"
}, {
  inputs: [],
  name: "AncestorsVaultLAP__InvalidClaimer",
  type: "error"
}, {
  inputs: [],
  name: "AncestorsVaultLAP__TransferFailed",
  type: "error"
}, {
  inputs: [],
  name: "AncestorsVaultLAP__ZeroRoyaltyPolicyLAP",
  type: "error"
}, {
  inputs: [],
  name: "ArbitrationPolicySP__NotDisputeModule",
  type: "error"
}, {
  inputs: [],
  name: "ArbitrationPolicySP__ZeroDisputeModule",
  type: "error"
}, {
  inputs: [],
  name: "ArbitrationPolicySP__ZeroPaymentToken",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__NotAbleToResolve",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__NotDisputeInitiator",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__NotInDisputeState",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__NotRegisteredIpId",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__NotWhitelistedArbitrationPolicy",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__NotWhitelistedArbitrationRelayer",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__NotWhitelistedDisputeTag",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__UnauthorizedAccess",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__ZeroArbitrationPolicy",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__ZeroArbitrationRelayer",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__ZeroDisputeTag",
  type: "error"
}, {
  inputs: [],
  name: "DisputeModule__ZeroLinkToDisputeEvidence",
  type: "error"
}, {
  inputs: [],
  name: "Governance__InconsistentState",
  type: "error"
}, {
  inputs: [],
  name: "Governance__NewStateIsTheSameWithOldState",
  type: "error"
}, {
  inputs: [],
  name: "Governance__OnlyProtocolAdmin",
  type: "error"
}, {
  inputs: [],
  name: "Governance__ProtocolPaused",
  type: "error"
}, {
  inputs: [{
    internalType: "string",
    name: "interfaceName",
    type: "string"
  }],
  name: "Governance__UnsupportedInterface",
  type: "error"
}, {
  inputs: [],
  name: "Governance__ZeroAddress",
  type: "error"
}, {
  inputs: [],
  name: "IPAccountRegistry_InvalidIpAccountImpl",
  type: "error"
}, {
  inputs: [],
  name: "IPAccount__ExpiredSignature",
  type: "error"
}, {
  inputs: [],
  name: "IPAccount__InvalidAccessController",
  type: "error"
}, {
  inputs: [],
  name: "IPAccount__InvalidCalldata",
  type: "error"
}, {
  inputs: [],
  name: "IPAccount__InvalidSignature",
  type: "error"
}, {
  inputs: [],
  name: "IPAccount__InvalidSigner",
  type: "error"
}, {
  inputs: [],
  name: "IPAssetRegistry__AlreadyRegistered",
  type: "error"
}, {
  inputs: [],
  name: "IPAssetRegistry__IPAccountAlreadyCreated",
  type: "error"
}, {
  inputs: [],
  name: "IPAssetRegistry__InvalidAccount",
  type: "error"
}, {
  inputs: [],
  name: "IPAssetRegistry__InvalidMetadataProvider",
  type: "error"
}, {
  inputs: [],
  name: "IPAssetRegistry__NotYetRegistered",
  type: "error"
}, {
  inputs: [],
  name: "IPAssetRegistry__RegistrantUnauthorized",
  type: "error"
}, {
  inputs: [],
  name: "IPAssetRegistry__ResolverInvalid",
  type: "error"
}, {
  inputs: [],
  name: "IPAssetRegistry__Unauthorized",
  type: "error"
}, {
  inputs: [],
  name: "IPResolver_InvalidIP",
  type: "error"
}, {
  inputs: [],
  name: "IPResolver_Unauthorized",
  type: "error"
}, {
  inputs: [],
  name: "LicenseRegistry__CallerNotLicensingModule",
  type: "error"
}, {
  inputs: [],
  name: "LicenseRegistry__NotTransferable",
  type: "error"
}, {
  inputs: [],
  name: "LicenseRegistry__RevokedLicense",
  type: "error"
}, {
  inputs: [],
  name: "LicenseRegistry__ZeroDisputeModule",
  type: "error"
}, {
  inputs: [],
  name: "LicenseRegistry__ZeroLicensingModule",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModuleAware__CallerNotLicensingModule",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__CallerNotLicenseRegistry",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__CallerNotLicensorAndPolicyNotSet",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__CommercialTermInNonCommercialPolicy",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__DerivativeRevShareSumExceedsMaxRNFTSupply",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__DerivativesCannotAddPolicy",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__DisputedIpId",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__EmptyLicenseUrl",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__EmptyParamName",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__FrameworkNotFound",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__IncompatibleLicensorCommercialPolicy",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__IncompatibleLicensorRoyaltyDerivativeRevShare",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__IncompatibleRoyaltyPolicyAddress",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__IncompatibleRoyaltyPolicyDerivativeRevShare",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__InvalidLicensor",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__InvalidPolicyFramework",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__LicensorDoesntHaveThisPolicy",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__LicensorNotRegistered",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__LinkParentParamFailed",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__LinkingRevokedLicense",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__MintLicenseParamFailed",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__MintingFeeTokenNotWhitelisted",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__MismatchBetweenRoyaltyPolicy",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__NotLicensee",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__ParamVerifierAlreadySet",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__ParamVerifierLengthMismatch",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__ParentIdEqualThanChild",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__PolicyAlreadySetForIpId",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__PolicyNotFound",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__RegisterPolicyFrameworkMismatch",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__RoyaltyPolicyNotWhitelisted",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__TransferParamFailed",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__UnauthorizedAccess",
  type: "error"
}, {
  inputs: [],
  name: "LicensingModule__UnregisteredFrameworkAddingPolicy",
  type: "error"
}, {
  inputs: [],
  name: "LicensorApprovalChecker__Unauthorized",
  type: "error"
}, {
  inputs: [],
  name: "MetadataProvider__HashInvalid",
  type: "error"
}, {
  inputs: [],
  name: "MetadataProvider__IPAssetOwnerInvalid",
  type: "error"
}, {
  inputs: [],
  name: "MetadataProvider__MetadataNotCompatible",
  type: "error"
}, {
  inputs: [],
  name: "MetadataProvider__NameInvalid",
  type: "error"
}, {
  inputs: [],
  name: "MetadataProvider__RegistrantInvalid",
  type: "error"
}, {
  inputs: [],
  name: "MetadataProvider__RegistrationDateInvalid",
  type: "error"
}, {
  inputs: [],
  name: "MetadataProvider__URIInvalid",
  type: "error"
}, {
  inputs: [],
  name: "MetadataProvider__Unauthorized",
  type: "error"
}, {
  inputs: [],
  name: "MetadataProvider__UpgradeProviderInvalid",
  type: "error"
}, {
  inputs: [],
  name: "MetadataProvider__UpgradeUnavailable",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__InterfaceIdZero",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__ModuleAddressNotContract",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__ModuleAddressZeroAddress",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__ModuleAlreadyRegistered",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__ModuleNotRegistered",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__ModuleNotSupportExpectedModuleTypeInterfaceId",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__ModuleTypeAlreadyRegistered",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__ModuleTypeEmptyString",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__ModuleTypeNotRegistered",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__NameAlreadyRegistered",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__NameDoesNotMatch",
  type: "error"
}, {
  inputs: [],
  name: "ModuleRegistry__NameEmptyString",
  type: "error"
}, {
  inputs: [],
  name: "Module_Unauthorized",
  type: "error"
}, {
  inputs: [{
    internalType: "address",
    name: "commercializer",
    type: "address"
  }],
  name: "PolicyFrameworkManager__CommercializerCheckerDoesNotSupportHook",
  type: "error"
}, {
  inputs: [],
  name: "PolicyFrameworkManager__GettingPolicyWrongFramework",
  type: "error"
}, {
  inputs: [],
  name: "RegistrationModule__InvalidOwner",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__CanOnlyMintSelectedPolicy",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__IncompatibleRoyaltyPolicy",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__NoParentsOnLinking",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__NoRoyaltyPolicySet",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__NotAllowedCaller",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__NotRegisteredIpId",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__NotWhitelistedRoyaltyPolicy",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__NotWhitelistedRoyaltyToken",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__ZeroLicensingModule",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__ZeroRoyaltyPolicy",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyModule__ZeroRoyaltyToken",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__AboveAncestorsLimit",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__AboveParentLimit",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__AboveRoyaltyStackLimit",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__ImplementationAlreadySet",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__InvalidAncestors",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__InvalidAncestorsHash",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__InvalidAncestorsLength",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__InvalidAncestorsRoyalty",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__InvalidParentRoyaltiesLength",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__InvalidRoyaltyAmountLength",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__LastPositionNotAbleToMintLicense",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__NotFullOwnership",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__NotRoyaltyModule",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__TransferFailed",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__UnlinkableToParents",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroAncestorsVaultImpl",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroLicensingModule",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroLiquidSplitFactory",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroLiquidSplitMain",
  type: "error"
}, {
  inputs: [],
  name: "RoyaltyPolicyLAP__ZeroRoyaltyModule",
  type: "error"
}];

var sepolia = {
  AccessController: "0xad64a4b2e18FF7D2f97aF083E7b193d7Dd141735",
  AncestorsVaultLAP: "0x1db575D163685F4b825aA2b0972B62CB6E7Ac2Db",
  ArbitrationPolicySP: "0x532BC697eFFd12Eb16C913b0df04ebEA87dea309",
  DisputeModule: "0x6157B19CBc151af2b36e0a2581001d32a22b2661",
  Governance: "0xc5Cdbb3359143C2449D03342D2F13F2F0e58c1b8",
  IPAccountImpl: "0x79792DccC6C58C303510fc1F7649e481C431aFb1",
  IPAccountRegistry: "0xBD2780F291588C8bDDf7F5874988fA9d3179d560",
  IPAssetRegistry: "0x292639452A975630802C17c9267169D93BD5a793",
  IPAssetRenderer: "0x1Ce95B7b333d71C00C3334a96713440d5A5A26dD",
  IPMetadataProvider: "0x31c65C12A6A3889cd08A055914931E2Fbe773dD6",
  IPResolver: "0x3809f4128B0B33AFb17576edafD7D4F4E2ABE933",
  LicenseRegistry: "0xc2BC7a2d5784768BDEd98436f2522A4931e2FBb4",
  LicensingModule: "0x950d766A1a0afDc33c3e653C861A8765cb42DbdC",
  MockERC20: "0x857308523a01B430cB112400976B9FC4A6429D55",
  MockERC721: "0x16d50f333B264b153B7BF1DD9fe65A2707B3281b",
  MockTokenGatedHook: "0x28C32a4B5B3E186d7f658C051d3Bb4a95243209a",
  ModuleRegistry: "0x5Aac3177F496F503Ac724A0D0A697f6ba9dA2C27",
  PILPolicyFrameworkManager: "0xeAABf2b80B7e069EE449B5629590A1cc0F9bC9C2",
  RegistrationModule: "0x613128e88b568768764824f898C8135efED97fA6",
  RoyaltyModule: "0xA6bEf9CC650A16939566c1da5d5088f3F028a865",
  RoyaltyPolicyLAP: "0x16eF58e959522727588921A92e9084d36E5d3855",
  TokenWithdrawalModule: "0x66738a5722e9Cd91B694bA39146CFEcE95457F04"
};

var IPAccountABI = [].concat(_toConsumableArray(IPAccountImplABI), _toConsumableArray(ErrorsABI));
var IPAssetRegistryConfig = {
  abi: IPAssetRegistryABI,
  address: getAddress(sepolia.IPAssetRegistry)
};
var AccessControllerConfig = {
  abi: [].concat(_toConsumableArray(AccessControllerABI), _toConsumableArray(ErrorsABI)),
  address: getAddress(sepolia.AccessController)
};
var DisputeModuleConfig = {
  abi: [].concat(_toConsumableArray(DisputeModuleABI), _toConsumableArray(ErrorsABI)),
  address: getAddress(sepolia.DisputeModule)
};
var LicenseRegistryConfig = {
  abi: IERC1155ABI,
  address: getAddress(sepolia.LicenseRegistry)
};
var LicensingModuleConfig = {
  abi: [].concat(_toConsumableArray(LicensingModuleABI), _toConsumableArray(ErrorsABI)),
  address: getAddress(sepolia.LicensingModule)
};
var RegistrationModuleConfig = {
  abi: [].concat(_toConsumableArray(RegistrationModuleABI), _toConsumableArray(ErrorsABI)),
  address: getAddress(sepolia.RegistrationModule)
};
var PILPolicyFrameworkManagerConfig = {
  abi: [].concat(_toConsumableArray(PILPolicyFrameworkManagerABI), _toConsumableArray(ErrorsABI)),
  address: getAddress(sepolia.PILPolicyFrameworkManager)
};
var RoyaltyPolicyLAPConfig = {
  address: getAddress(sepolia.RoyaltyPolicyLAP)
};

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function parseToBigInt(num) {
  return BigInt(num);
}
function waitTxAndFilterLog(_x, _x2, _x3) {
  return _waitTxAndFilterLog.apply(this, arguments);
}
function _waitTxAndFilterLog() {
  _waitTxAndFilterLog = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(client, txHash, params) {
    var txReceipt, targetLogs, _iterator, _step, log, currentLog;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return client.waitForTransactionReceipt({
            hash: txHash,
            confirmations: params.confirmations,
            pollingInterval: params.pollingInterval,
            timeout: params.timeout
          });
        case 2:
          txReceipt = _context.sent;
          targetLogs = [];
          _iterator = _createForOfIteratorHelper(txReceipt.logs);
          _context.prev = 5;
          _iterator.s();
        case 7:
          if ((_step = _iterator.n()).done) {
            _context.next = 21;
            break;
          }
          log = _step.value;
          _context.prev = 9;
          if (!(params.from && log.address !== params.from.toLowerCase())) {
            _context.next = 12;
            break;
          }
          return _context.abrupt("continue", 19);
        case 12:
          currentLog = decodeEventLog({
            abi: params.abi,
            eventName: params.eventName,
            data: log.data,
            topics: log.topics
          });
          targetLogs.push(currentLog);
          _context.next = 19;
          break;
        case 16:
          _context.prev = 16;
          _context.t0 = _context["catch"](9);
          return _context.abrupt("continue", 19);
        case 19:
          _context.next = 7;
          break;
        case 21:
          _context.next = 26;
          break;
        case 23:
          _context.prev = 23;
          _context.t1 = _context["catch"](5);
          _iterator.e(_context.t1);
        case 26:
          _context.prev = 26;
          _iterator.f();
          return _context.finish(26);
        case 29:
          if (!(targetLogs.length === 0)) {
            _context.next = 31;
            break;
          }
          throw new Error("not found event ".concat(params.eventName, " in target transaction"));
        case 31:
          return _context.abrupt("return", targetLogs);
        case 32:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[5, 23, 26, 29], [9, 16]]);
  }));
  return _waitTxAndFilterLog.apply(this, arguments);
}
function waitTx(_x4, _x5, _x6) {
  return _waitTx.apply(this, arguments);
}
function _waitTx() {
  _waitTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(client, txHash, params) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return client.waitForTransactionReceipt(_objectSpread2({
            hash: txHash
          }, params));
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _waitTx.apply(this, arguments);
}
function typedDataToBytes(typedData) {
  return encodeAbiParameters(parseAbiParameters(typedData["interface"]), typedData.data);
}
function chainStringToViemChain(chainId) {
  switch (chainId) {
    case "1":
    case "mainnet":
      return mainnet;
    case "11155111":
    case "sepolia":
      return sepolia$1;
    case "80001":
    case "mumbai":
    case "polygonMumbai":
      return polygonMumbai;
    default:
      throw new Error("chainId ".concat(chainId, " not supported"));
  }
}

function computeRoyaltyContext(_x, _x2) {
  return _computeRoyaltyContext.apply(this, arguments);
}
function _computeRoyaltyContext() {
  _computeRoyaltyContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(licenseIds, storyClient) {
    var royaltyContext, i, licenseData, royaltyPolicy, policy, targetRoyaltyAmount;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          royaltyContext = {
            targetAncestors: [],
            targetRoyaltyAmount: [],
            parentAncestors1: [],
            parentAncestors2: [],
            parentAncestorsRoyalties1: [],
            parentAncestorsRoyalties2: []
          };
          i = 0;
        case 2:
          if (!(i < licenseIds.length)) {
            _context.next = 16;
            break;
          }
          _context.next = 5;
          return storyClient.getLicense(licenseIds[i]);
        case 5:
          licenseData = _context.sent;
          _context.next = 8;
          return storyClient.getRoyaltyPolicy(licenseData.licensorIpId);
        case 8:
          royaltyPolicy = _context.sent;
          _context.next = 11;
          return storyClient.getPolicy(licenseData.policyId);
        case 11:
          policy = _context.sent;
          if (royaltyPolicy) {
            targetRoyaltyAmount = royaltyPolicy.targetRoyaltyAmount.map(function (e) {
              return parseInt(e);
            });
            if (i === 0) {
              royaltyContext.parentAncestors1 = royaltyPolicy.targetAncestors;
              royaltyContext.parentAncestorsRoyalties1 = targetRoyaltyAmount;
            } else {
              royaltyContext.parentAncestors2 = royaltyPolicy.targetAncestors;
              royaltyContext.parentAncestorsRoyalties2 = targetRoyaltyAmount;
            }
            updateRoyaltyContext(royaltyContext, [licenseData.licensorIpId], [parseInt(policy.pil.commercialRevShare)]);
            updateRoyaltyContext(royaltyContext, royaltyPolicy.targetAncestors, targetRoyaltyAmount);
          }
        case 13:
          i++;
          _context.next = 2;
          break;
        case 16:
          return _context.abrupt("return", royaltyContext);
        case 17:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _computeRoyaltyContext.apply(this, arguments);
}
function encodeRoyaltyContext(royaltyContext) {
  return typedDataToBytes({
    "interface": "(address[], uint32[], address[], address[], uint32[], uint32[])",
    data: [[royaltyContext.targetAncestors, royaltyContext.targetRoyaltyAmount, royaltyContext.parentAncestors1, royaltyContext.parentAncestors2, royaltyContext.parentAncestorsRoyalties1, royaltyContext.parentAncestorsRoyalties2]]
  });
}
function updateRoyaltyContext(royaltyContext, targetAncestors, targetRoyaltyAccounts) {
  for (var i = 0; i < targetAncestors.length; i++) {
    var index = royaltyContext.targetAncestors.indexOf(targetAncestors[i]);
    if (index === -1) {
      royaltyContext.targetAncestors.push(targetAncestors[i]);
      royaltyContext.targetRoyaltyAmount.push(targetRoyaltyAccounts[i]);
    } else {
      royaltyContext.targetRoyaltyAmount[index] += targetRoyaltyAccounts[i];
    }
  }
}

var IPAssetClient = /*#__PURE__*/function () {
  function IPAssetClient(rpcClient, wallet, storyClient) {
    _classCallCheck(this, IPAssetClient);
    _defineProperty(this, "ipAssetRegistryConfig", IPAssetRegistryConfig);
    _defineProperty(this, "registrationModuleConfig", RegistrationModuleConfig);
    this.wallet = wallet;
    this.rpcClient = rpcClient;
    this.storyClient = storyClient;
  }

  /**
   *  Registers a root-level IP into the protocol. Root-level IPs can be thought of as organizational hubs
   *  for encapsulating policies that actual IPs can use to register through. As such, a root-level IP is not an
   *  actual IP, but a container for IP policy management for their child IP assets.
   * @param request The request object that contains all data needed to register a root IP.
   *   @param request.policyId The policy that identifies the licensing terms of the IP.
   *   @param request.tokenContract The address of the NFT bound to the root-level IP.
   *   @param request.tokenId The token id of the NFT bound to the root-level IP.
   *   @param request.ipName [Optional] The name assigned to the new IP.
   *   @param request.contentHash [Optional] The content hash of the IP being registered.
   *   @param request.uri [Optional] An external URI to link to the IP.
   *   @param request.txOptions [Optional] The transaction options.
   * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID if waitForTxn is set to true.
   * @emits RootIPRegistered (msg.sender, ipId, policyId)
   */
  _createClass(IPAssetClient, [{
    key: "registerRootIp",
    value: function () {
      var _registerRootIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, ipId, _yield$this$rpcClient, call, txHash, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this.isNFTRegistered(SepoliaChainId, request.tokenContractAddress, request.tokenId);
            case 3:
              ipId = _context.sent;
              if (!(ipId !== "0x")) {
                _context.next = 6;
                break;
              }
              return _context.abrupt("return", {
                ipId: ipId
              });
            case 6:
              _context.next = 8;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, this.registrationModuleConfig), {}, {
                functionName: "registerRootIp",
                args: [parseToBigInt(request.policyId || "0"), getAddress(request.tokenContractAddress),
                // 0x Address
                parseToBigInt(request.tokenId), request.ipName || "", request.contentHash || HashZero, request.uri || ""],
                account: this.wallet.account
              }));
            case 8:
              _yield$this$rpcClient = _context.sent;
              call = _yield$this$rpcClient.request;
              _context.next = 12;
              return this.wallet.writeContract(call);
            case 12:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 20;
                break;
              }
              _context.next = 16;
              return waitTxAndFilterLog(this.rpcClient, txHash, _objectSpread2(_objectSpread2({}, this.ipAssetRegistryConfig), {}, {
                eventName: "IPRegistered"
              }));
            case 16:
              targetLogs = _context.sent;
              return _context.abrupt("return", {
                txHash: txHash,
                ipId: targetLogs[0].args.ipId
              });
            case 20:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 21:
              _context.next = 26;
              break;
            case 23:
              _context.prev = 23;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register root IP");
            case 26:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 23]]);
      }));
      function registerRootIp(_x) {
        return _registerRootIp.apply(this, arguments);
      }
      return registerRootIp;
    }()
    /**
     *  Registers derivative IPs into the protocol. Derivative IPs are IP assets that inherit policies from
     *  parent IPs by burning acquired license NFTs.
     * @param request The request object that contains all data needed to register a root IP.
     *   @param request.licenseIds The policy that identifies the licensing terms of the IP.
     *   @param request.tokenContract The address of the NFT bound to the derivative IP.
     *   @param request.tokenId The token id of the NFT bound to the derivative IP.
     *   @param request.ipName [Optional] The name assigned to the new IP.
     *   @param request.contentHash [Optional] The content hash of the IP being registered.
     *   @param request.uri [Optional] An external URI to link to the IP.
     *   @param request.txOptions [Optional] The transaction options.
     * @returns A Promise that resolves to an object containing the transaction hash and optional IP ID if waitForTxn is set to true.
     * @emits RootIPRegistered (msg.sender, ipId, policyId)
     */
  }, {
    key: "registerDerivativeIp",
    value: function () {
      var _registerDerivativeIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, ipId, licenseIds, royaltyContext, _yield$this$rpcClient2, call, txHash, targetLogs;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return this.isNFTRegistered(SepoliaChainId, request.tokenContractAddress, request.tokenId);
            case 3:
              ipId = _context2.sent;
              if (!(ipId !== "0x")) {
                _context2.next = 6;
                break;
              }
              return _context2.abrupt("return", {
                ipId: ipId
              });
            case 6:
              licenseIds = [];
              request.licenseIds.forEach(function (licenseId) {
                licenseIds.push(parseToBigInt(licenseId));
              });
              _context2.next = 10;
              return computeRoyaltyContext(request.licenseIds, this.storyClient);
            case 10:
              royaltyContext = _context2.sent;
              _context2.next = 13;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, this.registrationModuleConfig), {}, {
                functionName: "registerDerivativeIp",
                args: [licenseIds, getAddress(request.tokenContractAddress),
                // 0x Address
                parseToBigInt(request.tokenId), request.ipName || "", request.contentHash || HashZero, request.uri || "", encodeRoyaltyContext(royaltyContext)],
                account: this.wallet.account
              }));
            case 13:
              _yield$this$rpcClient2 = _context2.sent;
              call = _yield$this$rpcClient2.request;
              _context2.next = 17;
              return this.wallet.writeContract(call);
            case 17:
              txHash = _context2.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context2.next = 25;
                break;
              }
              _context2.next = 21;
              return waitTxAndFilterLog(this.rpcClient, txHash, _objectSpread2(_objectSpread2({}, this.ipAssetRegistryConfig), {}, {
                eventName: "IPRegistered"
              }));
            case 21:
              targetLogs = _context2.sent;
              return _context2.abrupt("return", {
                txHash: txHash,
                ipId: targetLogs[0].args.ipId
              });
            case 25:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 26:
              _context2.next = 31;
              break;
            case 28:
              _context2.prev = 28;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to register derivative IP");
            case 31:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 28]]);
      }));
      function registerDerivativeIp(_x2) {
        return _registerDerivativeIp.apply(this, arguments);
      }
      return registerDerivativeIp;
    }()
  }, {
    key: "isNFTRegistered",
    value: function () {
      var _isNFTRegistered = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(chainId, tokenAddress, tokenId) {
        var ipId, isRegistered;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.rpcClient.readContract(_objectSpread2(_objectSpread2({}, this.ipAssetRegistryConfig), {}, {
                functionName: "ipId",
                args: [parseToBigInt(chainId), tokenAddress, parseToBigInt(tokenId)]
              }));
            case 2:
              ipId = _context3.sent;
              _context3.next = 5;
              return this.rpcClient.readContract(_objectSpread2(_objectSpread2({}, this.ipAssetRegistryConfig), {}, {
                functionName: "isRegistered",
                args: [ipId]
              }));
            case 5:
              isRegistered = _context3.sent;
              return _context3.abrupt("return", isRegistered ? ipId : "0x");
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function isNFTRegistered(_x3, _x4, _x5) {
        return _isNFTRegistered.apply(this, arguments);
      }
      return isNFTRegistered;
    }()
  }]);
  return IPAssetClient;
}();

var PermissionClient = /*#__PURE__*/function () {
  function PermissionClient(rpcClient, wallet) {
    _classCallCheck(this, PermissionClient);
    _defineProperty(this, "ipAccountABI", IPAccountABI);
    _defineProperty(this, "accessControllerConfig", AccessControllerConfig);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
  }

  /**
   * Sets the permission for a specific function call
   * Each policy is represented as a mapping from an IP account address to a signer address to a recipient
   * address to a function selector to a permission level. The permission level can be 0 (ABSTAIN), 1 (ALLOW), or
   * 2 (DENY).
   * By default, all policies are set to 0 (ABSTAIN), which means that the permission is not set.
   * The owner of ipAccount by default has all permission.
   * address(0) => wildcard
   * bytes4(0) => wildcard
   * Specific permission overrides wildcard permission.
   * @param request The request object containing necessary data to set permissions.
   *   @param request.ipAsset The address of the IP account that grants the permission for `signer`
   *   @param request.signer The address that can call `to` on behalf of the `ipAccount`
   *   @param request.to The address that can be called by the `signer` (currently only modules can be `to`)
   *   @param request.func Optional. The function selector string of `to` that can be called by the `signer` on behalf of the `ipAccount`. Be default, it allows all functions.
   *   @param request.permission The new permission level
   * @returns A Promise that resolves to an object containing the transaction hash
   * @emits PermissionSet (ipAccountOwner, ipAccount, signer, to, func, permission)
   */
  _createClass(PermissionClient, [{
    key: "setPermission",
    value: function () {
      var _setPermission = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, IPAccountConfig, _yield$this$rpcClient, call, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              IPAccountConfig = {
                abi: this.ipAccountABI,
                address: getAddress(request.ipId)
              };
              _context.next = 4;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, IPAccountConfig), {}, {
                functionName: "execute",
                args: [this.accessControllerConfig.address, parseToBigInt(0), encodeFunctionData({
                  abi: this.accessControllerConfig.abi,
                  functionName: "setPermission",
                  args: [getAddress(request.ipId),
                  // 0x Address
                  getAddress(request.signer),
                  // 0x Address
                  getAddress(request.to),
                  // 0x Address
                  request.func || "0x00000000",
                  // bytes4
                  request.permission // uint8
                  ]
                })],

                account: this.wallet.account
              }));
            case 4:
              _yield$this$rpcClient = _context.sent;
              call = _yield$this$rpcClient.request;
              _context.next = 8;
              return this.wallet.writeContract(call);
            case 8:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 15;
                break;
              }
              _context.next = 12;
              return waitTxAndFilterLog(this.rpcClient, txHash, _objectSpread2(_objectSpread2({}, this.accessControllerConfig), {}, {
                eventName: "PermissionSet"
              }));
            case 12:
              return _context.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 15:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 16:
              _context.next = 21;
              break;
            case 18:
              _context.prev = 18;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to set permissions");
            case 21:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 18]]);
      }));
      function setPermission(_x) {
        return _setPermission.apply(this, arguments);
      }
      return setPermission;
    }()
  }]);
  return PermissionClient;
}();

var LicenseClient = /*#__PURE__*/function () {
  function LicenseClient(rpcClient, wallet, storyClient) {
    _classCallCheck(this, LicenseClient);
    _defineProperty(this, "ipAccountABI", IPAccountABI);
    _defineProperty(this, "licenseRegistryConfig", LicenseRegistryConfig);
    _defineProperty(this, "licensingModuleConfig", LicensingModuleConfig);
    this.wallet = wallet;
    this.rpcClient = rpcClient;
    this.storyClient = storyClient;
  }

  /**
   * Mints license NFTs representing a policy granted by a set of ipIds (licensors). This NFT needs to be
   * burned in order to link a derivative IP with its parents. If this is the first combination of policy and
   * licensors, a new licenseId will be created. If not, the license is fungible and an id will be reused.
   * @dev Only callable by the licensing module.
   * @param request The request object containing necessary data to mint a license.
   *   @param request.policyId The ID of the policy to be minted
   *   @param request.licensorIpId_ The ID of the IP granting the license (ie. licensor)
   *   @param request.mintAmount Number of licenses to mint. License NFT is fungible for same policy and same licensors
   *   @param request.receiver Receiver address of the minted license NFT(s).
   * @returns licenseId The ID of the minted license NFT(s).
   */
  _createClass(LicenseClient, [{
    key: "mintLicense",
    value: function () {
      var _mintLicense = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, royaltyContext, royaltyPolicy, _royaltyContext$targe, _royaltyContext$targe2, targetRoyaltyAmount, _yield$this$rpcClient, call, txHash, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              royaltyContext = {
                targetAncestors: [],
                targetRoyaltyAmount: [],
                parentAncestors1: [],
                parentAncestors2: [],
                parentAncestorsRoyalties1: [],
                parentAncestorsRoyalties2: []
              };
              _context.next = 4;
              return this.storyClient.getRoyaltyPolicy(request.licensorIpId);
            case 4:
              royaltyPolicy = _context.sent;
              if (royaltyPolicy) {
                (_royaltyContext$targe = royaltyContext.targetAncestors).push.apply(_royaltyContext$targe, _toConsumableArray(royaltyPolicy.targetAncestors));
                targetRoyaltyAmount = royaltyPolicy.targetRoyaltyAmount.map(function (e) {
                  return parseInt(e);
                });
                (_royaltyContext$targe2 = royaltyContext.targetRoyaltyAmount).push.apply(_royaltyContext$targe2, _toConsumableArray(targetRoyaltyAmount));
              }
              _context.next = 8;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, this.licensingModuleConfig), {}, {
                functionName: "mintLicense",
                args: [parseToBigInt(request.policyId), request.licensorIpId, parseToBigInt(request.mintAmount), getAddress(request.receiverAddress), encodeRoyaltyContext(royaltyContext)],
                account: this.wallet.account
              }));
            case 8:
              _yield$this$rpcClient = _context.sent;
              call = _yield$this$rpcClient.request;
              _context.next = 12;
              return this.wallet.writeContract(call);
            case 12:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 20;
                break;
              }
              _context.next = 16;
              return waitTxAndFilterLog(this.rpcClient, txHash, _objectSpread2(_objectSpread2({}, this.licenseRegistryConfig), {}, {
                eventName: "TransferSingle",
                from: this.licenseRegistryConfig.address
              }));
            case 16:
              targetLogs = _context.sent;
              return _context.abrupt("return", {
                txHash: txHash,
                licenseId: targetLogs[0].args.id.toString()
              });
            case 20:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 21:
              _context.next = 26;
              break;
            case 23:
              _context.prev = 23;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to mint license");
            case 26:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 23]]);
      }));
      function mintLicense(_x) {
        return _mintLicense.apply(this, arguments);
      }
      return mintLicense;
    }()
  }, {
    key: "linkIpToParent",
    value: function () {
      var _linkIpToParent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, IPAccountConfig, licenseIds, royaltyContext, _yield$this$rpcClient2, call, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              IPAccountConfig = {
                abi: this.ipAccountABI,
                address: getAddress(request.childIpId)
              };
              licenseIds = [];
              request.licenseIds.forEach(function (licenseId) {
                licenseIds.push(parseToBigInt(licenseId));
              });
              _context2.next = 6;
              return computeRoyaltyContext(request.licenseIds, this.storyClient);
            case 6:
              royaltyContext = _context2.sent;
              _context2.next = 9;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, IPAccountConfig), {}, {
                functionName: "execute",
                args: [this.licensingModuleConfig.address, parseToBigInt(0), encodeFunctionData({
                  abi: this.licensingModuleConfig.abi,
                  functionName: "linkIpToParents",
                  args: [licenseIds, getAddress(request.childIpId), encodeRoyaltyContext(royaltyContext)]
                })],
                account: this.wallet.account
              }));
            case 9:
              _yield$this$rpcClient2 = _context2.sent;
              call = _yield$this$rpcClient2.request;
              _context2.next = 13;
              return this.wallet.writeContract(call);
            case 13:
              txHash = _context2.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context2.next = 20;
                break;
              }
              _context2.next = 17;
              return waitTxAndFilterLog(this.rpcClient, txHash, _objectSpread2(_objectSpread2({}, LicenseRegistryConfig), {}, {
                eventName: "TransferBatch"
              }));
            case 17:
              return _context2.abrupt("return", {
                txHash: txHash,
                success: true
              });
            case 20:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 21:
              _context2.next = 26;
              break;
            case 23:
              _context2.prev = 23;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to link IP to parents");
            case 26:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 23]]);
      }));
      function linkIpToParent(_x2) {
        return _linkIpToParent.apply(this, arguments);
      }
      return linkIpToParent;
    }()
  }]);
  return LicenseClient;
}();

var PolicyClient = /*#__PURE__*/function () {
  function PolicyClient(rpcClient, wallet) {
    _classCallCheck(this, PolicyClient);
    _defineProperty(this, "ipAccountABI", IPAccountABI);
    _defineProperty(this, "licensingModuleConfig", LicensingModuleConfig);
    _defineProperty(this, "pilPolicyFrameworkManagerConfig", PILPolicyFrameworkManagerConfig);
    _defineProperty(this, "royaltyPolicyLAPConfig", RoyaltyPolicyLAPConfig);
    this.wallet = wallet;
    this.rpcClient = rpcClient;
  }

  /**
   * Registers a PIL policy to the registry
   * Internally, this function must generate a Licensing.Policy struct and call registerPolicy.
   * @param request - the licensing parameters for the Programmable IP License v1 (PIL) standard.
   *   @param request.transferable Whether or not the license is transferable
   *   @param request.attribution Whether or not attribution is required when reproducing the work
   *   @param request.commercialUse Whether or not the work can be used commercially
   *   @param request.commercialAttribution Whether or not attribution is required when reproducing the work commercially
   *   @param request.commercializerChecker commericializers that are allowed to commercially exploit the work. If zero address, then no restrictions is enforced.
   *   @param request.commercialRevShare Percentage of revenue that must be shared with the licensor
   *   @param request.derivativesAllowed Whether or not the licensee can create derivatives of his work
   *   @param request.derivativesAttribution Whether or not attribution is required for derivatives of the work
   *   @param request.derivativesApproval Whether or not the licensor must approve derivatives of the work before they can be linked to the licensor IP ID
   *   @param request.derivativesReciprocal Whether or not the licensee must license derivatives of the work under the same terms.
   *   @param request.territories List of territories where the license is valid. If empty, global.
   *   @param request.distributionChannels List of distribution channels where the license is valid. Empty if no restrictions.
   *   @param request.royaltyPolicy Address of a royalty policy contract (e.g. RoyaltyPolicyLS) that will handle royalty payments
   * @returns the transaction hash and the policy ID if the txOptions.waitForTransaction is set to true
   */
  _createClass(PolicyClient, [{
    key: "registerPILPolicy",
    value: function () {
      var _registerPILPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, frameworkData, policyId, _yield$this$rpcClient, call, txHash, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              // First check if the policy exists
              frameworkData = {
                attribution: request.attribution || false,
                commercialUse: request.commercialUse || false,
                commercialAttribution: request.commercialAttribution || false,
                commercializerChecker: request.commercializerChecker || zeroAddress,
                commercializerCheckerData: request.commercializerCheckerData || "0x",
                commercialRevShare: request.commercialRevShare || 0,
                derivativesAllowed: request.derivativesAllowed || false,
                derivativesAttribution: request.derivativesAttribution || false,
                derivativesApproval: request.derivativesApproval || false,
                derivativesReciprocal: request.derivativesReciprocal || false,
                territories: request.territories || [],
                distributionChannels: request.distributionChannels || [],
                contentRestrictions: request.contentRestrictions || []
              };
              _context.next = 4;
              return this.getPolicyId(request.transferable, this.encodeFrameworkData(frameworkData), typedDataToBytes({
                "interface": "uint32",
                data: [request.commercialRevShare || 0]
              }), request.mintingFee || "0", request.mintingFeeToken || zeroAddress, request.royaltyPolicy || zeroAddress);
            case 4:
              policyId = _context.sent;
              if (!(policyId !== 0)) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return", {
                policyId: policyId.toString()
              });
            case 7:
              _context.next = 9;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, this.pilPolicyFrameworkManagerConfig), {}, {
                functionName: "registerPolicy",
                args: [{
                  transferable: request.transferable,
                  royaltyPolicy: request.royaltyPolicy || zeroAddress,
                  mintingFee: parseToBigInt(request.mintingFee || "0"),
                  mintingFeeToken: request.mintingFeeToken || zeroAddress,
                  policy: {
                    attribution: request.attribution || false,
                    commercialUse: request.commercialUse || false,
                    commercialAttribution: request.commercialAttribution || false,
                    commercialRevShare: request.commercialRevShare || 0,
                    derivativesAllowed: request.derivativesAllowed || false,
                    derivativesAttribution: request.derivativesAttribution || false,
                    derivativesApproval: request.derivativesApproval || false,
                    derivativesReciprocal: request.derivativesReciprocal || false,
                    commercializerChecker: request.commercializerChecker || zeroAddress,
                    commercializerCheckerData: request.commercializerCheckerData || "0x",
                    territories: request.territories || [],
                    distributionChannels: request.distributionChannels || [],
                    contentRestrictions: request.contentRestrictions || []
                  }
                }],
                account: this.wallet.account
              }));
            case 9:
              _yield$this$rpcClient = _context.sent;
              call = _yield$this$rpcClient.request;
              _context.next = 13;
              return this.wallet.writeContract(call);
            case 13:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 21;
                break;
              }
              _context.next = 17;
              return waitTxAndFilterLog(this.rpcClient, txHash, _objectSpread2(_objectSpread2({}, this.licensingModuleConfig), {}, {
                eventName: "PolicyRegistered"
              }));
            case 17:
              targetLogs = _context.sent;
              return _context.abrupt("return", {
                txHash: txHash,
                policyId: targetLogs[0].args.policyId.toString()
              });
            case 21:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 22:
              _context.next = 27;
              break;
            case 24:
              _context.prev = 24;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to register policy");
            case 27:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 24]]);
      }));
      function registerPILPolicy(_x) {
        return _registerPILPolicy.apply(this, arguments);
      }
      return registerPILPolicy;
    }()
    /**
     * Convenient function to register a PIL social remix policy to the registry
     * Internally, this function must generate a Licensing.Policy struct and call registerPolicy.
     * @param request - the licensing parameters for the Programmable IP License v1 (PIL) standard.
     *   @param request.territories List of territories where the license is valid. If empty, global.
     *   @param request.distributionChannels List of distribution channels where the license is valid. Empty if no restrictions.
     *   @param request.contentRestrictions List of content restrictions where the license is valid. Empty if no restrictions.
     * @returns the transaction hash and the policy ID if the txOptions.waitForTransaction is set to true
     */
  }, {
    key: "registerPILSocialRemixPolicy",
    value: function () {
      var _registerPILSocialRemixPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, frameworkData, policyId, _yield$this$rpcClient2, call, txHash, targetLog;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              // First check if the policy exists
              frameworkData = {
                attribution: true,
                commercialUse: false,
                commercialAttribution: false,
                commercializerChecker: zeroAddress,
                commercializerCheckerData: "0x",
                commercialRevShare: 0,
                derivativesAllowed: true,
                derivativesAttribution: true,
                derivativesApproval: false,
                derivativesReciprocal: true,
                territories: request.territories || [],
                distributionChannels: request.distributionChannels || [],
                contentRestrictions: request.contentRestrictions || []
              };
              _context2.next = 4;
              return this.getPolicyId(true, this.encodeFrameworkData(frameworkData), typedDataToBytes({
                "interface": "uint32",
                data: [0]
              }), "0", zeroAddress, zeroAddress);
            case 4:
              policyId = _context2.sent;
              if (!(policyId !== 0)) {
                _context2.next = 7;
                break;
              }
              return _context2.abrupt("return", {
                policyId: policyId.toString()
              });
            case 7:
              _context2.next = 9;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, this.pilPolicyFrameworkManagerConfig), {}, {
                functionName: "registerPolicy",
                args: [{
                  transferable: true,
                  royaltyPolicy: zeroAddress,
                  mintingFee: parseToBigInt(0),
                  mintingFeeToken: zeroAddress,
                  policy: {
                    attribution: true,
                    commercialUse: false,
                    commercialAttribution: false,
                    commercialRevShare: 0,
                    derivativesAllowed: true,
                    derivativesAttribution: true,
                    derivativesApproval: false,
                    derivativesReciprocal: true,
                    commercializerChecker: zeroAddress,
                    commercializerCheckerData: "0x",
                    territories: request.territories || [],
                    distributionChannels: request.distributionChannels || [],
                    contentRestrictions: request.contentRestrictions || []
                  }
                }],
                account: this.wallet.account
              }));
            case 9:
              _yield$this$rpcClient2 = _context2.sent;
              call = _yield$this$rpcClient2.request;
              _context2.next = 13;
              return this.wallet.writeContract(call);
            case 13:
              txHash = _context2.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context2.next = 21;
                break;
              }
              _context2.next = 17;
              return waitTxAndFilterLog(this.rpcClient, txHash, _objectSpread2(_objectSpread2({}, this.licensingModuleConfig), {}, {
                eventName: "PolicyRegistered"
              }));
            case 17:
              targetLog = _context2.sent;
              return _context2.abrupt("return", {
                txHash: txHash,
                policyId: targetLog[0].args.policyId.toString()
              });
            case 21:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 22:
              _context2.next = 27;
              break;
            case 24:
              _context2.prev = 24;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to register social remix policy");
            case 27:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 24]]);
      }));
      function registerPILSocialRemixPolicy(_x2) {
        return _registerPILSocialRemixPolicy.apply(this, arguments);
      }
      return registerPILSocialRemixPolicy;
    }()
    /**
     * Convenient function to register a PIL social remix policy to the registry
     * Internally, this function must generate a Licensing.Policy struct and call registerPolicy.
     * @param request - the licensing parameters for the Programmable IP License v1 (PIL) standard.
     *   @param request.commercialRevShare Percentage of revenue that must be shared with the licensor
     *   @param mintingFee Fee to be paid when minting a license
     *   @param mintingFeeToken Token to be used to pay the minting fee
     *   @param request.territories List of territories where the license is valid. If empty, global.
     *   @param request.distributionChannels List of distribution channels where the license is valid. Empty if no restrictions.
     *   @param request.contentRestrictions List of content restrictions where the license is valid. Empty if no restrictions.
     * @returns the transaction hash and the policy ID if the txOptions.waitForTransaction is set to true
     */
  }, {
    key: "registerPILCommercialUsePolicy",
    value: function () {
      var _registerPILCommercialUsePolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions3, frameworkData, policyId, _yield$this$rpcClient3, call, txHash, targetLogs;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              // First check if the policy exists
              frameworkData = {
                attribution: true,
                commercialUse: true,
                commercialAttribution: true,
                commercializerChecker: zeroAddress,
                commercializerCheckerData: "0x",
                commercialRevShare: request.commercialRevShare,
                derivativesAllowed: true,
                derivativesAttribution: true,
                derivativesApproval: false,
                derivativesReciprocal: true,
                territories: request.territories || [],
                distributionChannels: request.distributionChannels || [],
                contentRestrictions: request.contentRestrictions || []
              };
              _context3.next = 4;
              return this.getPolicyId(true, this.encodeFrameworkData(frameworkData), typedDataToBytes({
                "interface": "uint32",
                data: [request.commercialRevShare]
              }), request.mintingFee || "0", request.mintingFeeToken || zeroAddress, this.royaltyPolicyLAPConfig.address);
            case 4:
              policyId = _context3.sent;
              if (!(policyId !== 0)) {
                _context3.next = 7;
                break;
              }
              return _context3.abrupt("return", {
                policyId: policyId.toString()
              });
            case 7:
              _context3.next = 9;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, this.pilPolicyFrameworkManagerConfig), {}, {
                functionName: "registerPolicy",
                args: [{
                  transferable: true,
                  royaltyPolicy: this.royaltyPolicyLAPConfig.address,
                  mintingFee: parseToBigInt(request.mintingFee || "0"),
                  mintingFeeToken: request.mintingFeeToken || zeroAddress,
                  policy: {
                    attribution: true,
                    commercialUse: true,
                    commercialAttribution: true,
                    commercialRevShare: request.commercialRevShare,
                    derivativesAllowed: true,
                    derivativesAttribution: true,
                    derivativesApproval: false,
                    derivativesReciprocal: true,
                    commercializerChecker: zeroAddress,
                    commercializerCheckerData: "0x",
                    territories: request.territories || [],
                    distributionChannels: request.distributionChannels || [],
                    contentRestrictions: request.contentRestrictions || []
                  }
                }],
                account: this.wallet.account
              }));
            case 9:
              _yield$this$rpcClient3 = _context3.sent;
              call = _yield$this$rpcClient3.request;
              _context3.next = 13;
              return this.wallet.writeContract(call);
            case 13:
              txHash = _context3.sent;
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.waitForTransaction)) {
                _context3.next = 21;
                break;
              }
              _context3.next = 17;
              return waitTxAndFilterLog(this.rpcClient, txHash, _objectSpread2(_objectSpread2({}, this.licensingModuleConfig), {}, {
                eventName: "PolicyRegistered"
              }));
            case 17:
              targetLogs = _context3.sent;
              return _context3.abrupt("return", {
                txHash: txHash,
                policyId: targetLogs[0].args.policyId.toString()
              });
            case 21:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 22:
              _context3.next = 27;
              break;
            case 24:
              _context3.prev = 24;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to register commercial use policy");
            case 27:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 24]]);
      }));
      function registerPILCommercialUsePolicy(_x3) {
        return _registerPILCommercialUsePolicy.apply(this, arguments);
      }
      return registerPILCommercialUsePolicy;
    }()
  }, {
    key: "getPolicyId",
    value: function () {
      var _getPolicyId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(transferable, frameworkData, royaltyData, mintingFee, mintingFeeToken, royaltyPolicy, policyFramework) {
        var data;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.rpcClient.readContract(_objectSpread2(_objectSpread2({}, this.licensingModuleConfig), {}, {
                functionName: "getPolicyId",
                args: [{
                  isLicenseTransferable: transferable,
                  policyFramework: policyFramework || this.pilPolicyFrameworkManagerConfig.address,
                  frameworkData: frameworkData,
                  royaltyPolicy: royaltyPolicy,
                  royaltyData: royaltyData,
                  mintingFee: parseToBigInt(mintingFee),
                  mintingFeeToken: mintingFeeToken
                }]
              }));
            case 2:
              data = _context4.sent;
              return _context4.abrupt("return", Number(data));
            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getPolicyId(_x4, _x5, _x6, _x7, _x8, _x9, _x10) {
        return _getPolicyId.apply(this, arguments);
      }
      return getPolicyId;
    }()
  }, {
    key: "encodeFrameworkData",
    value: function encodeFrameworkData(data) {
      return typedDataToBytes({
        "interface": "(bool, bool, bool, address, bytes, uint32, bool, bool, bool, bool, string[], string[], string[])",
        data: [[data.attribution, data.commercialUse, data.commercialAttribution, data.commercializerChecker, data.commercializerCheckerData, data.commercialRevShare, data.derivativesAllowed, data.derivativesAttribution, data.derivativesApproval, data.derivativesReciprocal, data.territories, data.distributionChannels, data.contentRestrictions]]
      });
    }

    /**
     * Adds a policy to the set of policies of an IP
     * @param request The request object containing details to add a policy to an IP
     *   @param request.ipId The id of the IP
     *   @param request.polId The id of the policy
     * @return the transaction hash and the index of the policy in the IP's policy set if the txOptions.waitForTransaction is set to true
     */
  }, {
    key: "addPolicyToIp",
    value: function () {
      var _addPolicyToIp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request) {
        var _request$txOptions4, IPAccountConfig, _yield$this$rpcClient4, call, txHash, targetLogs;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              IPAccountConfig = {
                abi: this.ipAccountABI,
                address: getAddress(request.ipId)
              };
              _context5.next = 4;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, IPAccountConfig), {}, {
                functionName: "execute",
                args: [this.licensingModuleConfig.address, parseToBigInt(0), encodeFunctionData({
                  abi: this.licensingModuleConfig.abi,
                  functionName: "addPolicyToIp",
                  args: [getAddress(request.ipId), parseToBigInt(request.policyId)]
                })],
                account: this.wallet.account
              }));
            case 4:
              _yield$this$rpcClient4 = _context5.sent;
              call = _yield$this$rpcClient4.request;
              _context5.next = 8;
              return this.wallet.writeContract(call);
            case 8:
              txHash = _context5.sent;
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.waitForTransaction)) {
                _context5.next = 16;
                break;
              }
              _context5.next = 12;
              return waitTxAndFilterLog(this.rpcClient, txHash, _objectSpread2(_objectSpread2({}, this.licensingModuleConfig), {}, {
                eventName: "PolicyAddedToIpId"
              }));
            case 12:
              targetLogs = _context5.sent;
              return _context5.abrupt("return", {
                txHash: txHash,
                index: targetLogs[0].args.index.toString()
              });
            case 16:
              return _context5.abrupt("return", {
                txHash: txHash
              });
            case 17:
              _context5.next = 22;
              break;
            case 19:
              _context5.prev = 19;
              _context5.t0 = _context5["catch"](0);
              handleError(_context5.t0, "Failed to add policy to IP");
            case 22:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[0, 19]]);
      }));
      function addPolicyToIp(_x11) {
        return _addPolicyToIp.apply(this, arguments);
      }
      return addPolicyToIp;
    }()
  }]);
  return PolicyClient;
}();

var DisputeClient = /*#__PURE__*/function () {
  function DisputeClient(rpcClient, wallet) {
    _classCallCheck(this, DisputeClient);
    _defineProperty(this, "disputeModuleConfig", DisputeModuleConfig);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
  }

  /**
   * Raises a dispute on a given ipId
   * @param request - The request object containing necessary data to raise a dispute.
   *   @param request.targetIpId - The IP ID that is the target of the dispute.
   *   @param request.arbitrationPolicy - The address of the arbitration policy.
   *   @param request.linkToDisputeEvidence - The link to the dispute evidence.
   *   @param request.targetTag - The target tag of the dispute.
   *   @param request.calldata - Optional calldata to initialize the policy.
   *   @param request.txOptions - Optional transaction options.
   * @returns A Promise that resolves to a RaiseDisputeResponse containing the transaction hash.
   * @throws `NotRegisteredIpId` if targetIpId is not registered in the IPA Registry.
   * @throws `NotWhitelistedDisputeTag` if targetTag is not whitelisted.
   * @throws `ZeroLinkToDisputeEvidence` if linkToDisputeEvidence is empty
   * @calls raiseDispute(address _targetIpId, string memory _linkToDisputeEvidence, bytes32 _targetTag, bytes calldata _data) external nonReentrant returns (uint256) {
   * @emits DisputeRaised (disputeId_, targetIpId, msg.sender, arbitrationPolicy, linkToDisputeEvidence, targetTag, calldata);
   */
  _createClass(DisputeClient, [{
    key: "raiseDispute",
    value: function () {
      var _raiseDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, _yield$this$rpcClient, call, txHash, targetLogs;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, this.disputeModuleConfig), {}, {
                functionName: "raiseDispute",
                args: [request.targetIpId, request.linkToDisputeEvidence, stringToHex(request.targetTag, {
                  size: 32
                }), request.calldata || "0x"],
                account: this.wallet.account
              }));
            case 3:
              _yield$this$rpcClient = _context.sent;
              call = _yield$this$rpcClient.request;
              _context.next = 7;
              return this.wallet.writeContract(call);
            case 7:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 13;
                break;
              }
              _context.next = 11;
              return waitTxAndFilterLog(this.rpcClient, txHash, _objectSpread2(_objectSpread2({}, this.disputeModuleConfig), {}, {
                eventName: "DisputeRaised"
              }));
            case 11:
              targetLogs = _context.sent;
              return _context.abrupt("return", {
                txHash: txHash,
                disputeId: BigInt(targetLogs[0].args.disputeId).toString()
              });
            case 13:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to raise dispute");
            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 16]]);
      }));
      function raiseDispute(_x) {
        return _raiseDispute.apply(this, arguments);
      }
      return raiseDispute;
    }()
    /**
     * Cancels an ongoing dispute
     * @param request The request object containing details to cancel the dispute.
     *   @param request.disputeId The ID of the dispute to be cancelled.
     *   @param request.calldata Optional additional data used in the cancellation process.
     * @returns A Promise that resolves to a CancelDisputeResponse containing the transaction hash.
     * @throws NotInDisputeState, if the currentTag of the Dispute is not being disputed
     * @throws NotDisputeInitiator, if the transaction executor is not the one that initiated the dispute
     * @throws error if the Dispute's ArbitrationPolicy contract is not valid
     * @calls cancelDispute(uint256 _disputeId, bytes calldata _data) external nonReentrant {
     * @emits DisputeCancelled (_disputeId, _data);
     */
  }, {
    key: "cancelDispute",
    value: function () {
      var _cancelDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, _yield$this$rpcClient2, call, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, this.disputeModuleConfig), {}, {
                functionName: "cancelDispute",
                args: [BigInt(request.disputeId), request.calldata ? request.calldata : "0x"],
                account: this.wallet.account
              }));
            case 3:
              _yield$this$rpcClient2 = _context2.sent;
              call = _yield$this$rpcClient2.request;
              _context2.next = 7;
              return this.wallet.writeContract(call);
            case 7:
              txHash = _context2.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context2.next = 11;
                break;
              }
              _context2.next = 11;
              return waitTx(this.rpcClient, txHash);
            case 11:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 14:
              _context2.prev = 14;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to cancel dispute");
            case 17:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 14]]);
      }));
      function cancelDispute(_x2) {
        return _cancelDispute.apply(this, arguments);
      }
      return cancelDispute;
    }()
    /**
     * Resolves a dispute after it has been judged
     * @param request The request object containing details to resolve the dispute.
     *   @param request.disputeId The ID of the dispute to be resolved.
     * @returns A Promise that resolves to a ResolveDisputeResponse.
     * @throws NotAbleToResolve, if currentTag is still in dispute (i.e still needs a judgement to be set)
     * @throws NotDisputeInitiator, if the transaction executor is not the one that initiated the dispute
     * @emits DisputeResolved (_disputeId)
     */
  }, {
    key: "resolveDispute",
    value: function () {
      var _resolveDispute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {
        var _request$txOptions3, _yield$this$rpcClient3, call, txHash;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, this.disputeModuleConfig), {}, {
                functionName: "resolveDispute",
                args: [BigInt(request.disputeId)],
                account: this.wallet.account
              }));
            case 3:
              _yield$this$rpcClient3 = _context3.sent;
              call = _yield$this$rpcClient3.request;
              _context3.next = 7;
              return this.wallet.writeContract(call);
            case 7:
              txHash = _context3.sent;
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.waitForTransaction)) {
                _context3.next = 11;
                break;
              }
              _context3.next = 11;
              return waitTx(this.rpcClient, txHash);
            case 11:
              return _context3.abrupt("return", {
                txHash: txHash
              });
            case 14:
              _context3.prev = 14;
              _context3.t0 = _context3["catch"](0);
              handleError(_context3.t0, "Failed to cancel dispute");
            case 17:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[0, 14]]);
      }));
      function resolveDispute(_x3) {
        return _resolveDispute.apply(this, arguments);
      }
      return resolveDispute;
    }()
  }]);
  return DisputeClient;
}();

var IPAccountClient = /*#__PURE__*/function () {
  function IPAccountClient(rpcClient, wallet) {
    _classCallCheck(this, IPAccountClient);
    _defineProperty(this, "ipAccountABI", IPAccountABI);
    this.wallet = wallet;
    this.rpcClient = rpcClient;
  }

  /** Executes a transaction from the IP Account.
   * @param request The request object containing necessary data to execute IP Account a transaction.
   *   @param request.to The recipient of the transaction.
   *   @param request.value The amount of Ether to send.
   *   @param request.data The data to send along with the transaction.
   * @returns Tx hash for the transaction.
   */
  _createClass(IPAccountClient, [{
    key: "execute",
    value: function () {
      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
        var _request$txOptions, IPAccountConfig, _yield$this$rpcClient, call, txHash;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              IPAccountConfig = {
                abi: this.ipAccountABI,
                address: getAddress(request.accountAddress)
              };
              _context.next = 4;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, IPAccountConfig), {}, {
                functionName: "execute",
                args: [request.to, parseToBigInt(0), request.data],
                account: this.wallet.account
              }));
            case 4:
              _yield$this$rpcClient = _context.sent;
              call = _yield$this$rpcClient.request;
              _context.next = 8;
              return this.wallet.writeContract(call);
            case 8:
              txHash = _context.sent;
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.waitForTransaction)) {
                _context.next = 12;
                break;
              }
              _context.next = 12;
              return waitTx(this.rpcClient, txHash);
            case 12:
              return _context.abrupt("return", {
                txHash: txHash
              });
            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](0);
              handleError(_context.t0, "Failed to execute the IP Account transaction");
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 15]]);
      }));
      function execute(_x) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
    /** Executes a transaction from the IP Account.
     * @param request The request object containing necessary data to execute IP Account a transaction.
     *   @param request.to The recipient of the transaction.
     *   @param request.value The amount of Ether to send.
     *   @param request.data The data to send along with the transaction.
     *   @param request.signer The signer of the transaction.
     *   @param request.deadline The deadline of the transaction signature.
     *   @param request.signature The signature of the transaction, EIP-712 encoded.
     * @returns Tx hash for the transaction.
     */
  }, {
    key: "executeWithSig",
    value: function () {
      var _executeWithSig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request) {
        var _request$txOptions2, IPAccountConfig, _yield$this$rpcClient2, call, txHash;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              IPAccountConfig = {
                abi: this.ipAccountABI,
                address: getAddress(request.accountAddress)
              };
              _context2.next = 4;
              return this.rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, IPAccountConfig), {}, {
                functionName: "executeWithSig",
                args: [request.to, parseToBigInt(0), request.data, request.signer, parseToBigInt(request.deadline), request.signature],
                account: this.wallet.account
              }));
            case 4:
              _yield$this$rpcClient2 = _context2.sent;
              call = _yield$this$rpcClient2.request;
              _context2.next = 8;
              return this.wallet.writeContract(call);
            case 8:
              txHash = _context2.sent;
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.waitForTransaction)) {
                _context2.next = 12;
                break;
              }
              _context2.next = 12;
              return waitTx(this.rpcClient, txHash);
            case 12:
              return _context2.abrupt("return", {
                txHash: txHash
              });
            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](0);
              handleError(_context2.t0, "Failed to execute with signature for the IP Account transaction");
            case 18:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 15]]);
      }));
      function executeWithSig(_x2) {
        return _executeWithSig.apply(this, arguments);
      }
      return executeWithSig;
    }()
  }]);
  return IPAccountClient;
}();

var StoryAPIClient = /*#__PURE__*/function () {
  function StoryAPIClient() {
    _classCallCheck(this, StoryAPIClient);
    this.httpClient = axios.create({
      baseURL: "https://api.storyprotocol.net",
      timeout: 60000,
      headers: {
        "x-api-key": "U3RvcnlQcm90b2NvbFRlc3RBUElLRVk="
      }
    });
  }
  _createClass(StoryAPIClient, [{
    key: "getRoyaltyPolicy",
    value: function () {
      var _getRoyaltyPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ipId) {
        var royaltyPolicyResp;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.httpClient.get("/api/v1/royalties/policies/".concat(ipId));
            case 2:
              royaltyPolicyResp = _context.sent;
              return _context.abrupt("return", royaltyPolicyResp.data.data);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getRoyaltyPolicy(_x) {
        return _getRoyaltyPolicy.apply(this, arguments);
      }
      return getRoyaltyPolicy;
    }()
  }, {
    key: "getLicense",
    value: function () {
      var _getLicense = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(licenseId) {
        var licenseResp;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.httpClient.get("/api/v1/licenses/".concat(licenseId));
            case 2:
              licenseResp = _context2.sent;
              return _context2.abrupt("return", licenseResp.data.data);
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getLicense(_x2) {
        return _getLicense.apply(this, arguments);
      }
      return getLicense;
    }()
  }, {
    key: "getPolicy",
    value: function () {
      var _getPolicy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(policyId) {
        var policyResp;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.httpClient.get("/api/v1/policies/".concat(policyId));
            case 2:
              policyResp = _context3.sent;
              return _context3.abrupt("return", policyResp.data.data);
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getPolicy(_x3) {
        return _getPolicy.apply(this, arguments);
      }
      return getPolicy;
    }()
  }]);
  return StoryAPIClient;
}();

if (typeof process !== "undefined") {
  dotenv.config();
}
/**
 * The StoryClient is the main entry point for the SDK.
 */
var StoryClient = /*#__PURE__*/function () {
  /**
   * @param config - the configuration for the SDK client
   */
  function StoryClient(config) {
    _classCallCheck(this, StoryClient);
    _defineProperty(this, "_ipAsset", null);
    _defineProperty(this, "_permission", null);
    _defineProperty(this, "_license", null);
    _defineProperty(this, "_policy", null);
    _defineProperty(this, "_dispute", null);
    _defineProperty(this, "_ipAccount", null);
    this.config = config;
    if (!this.config.transport) {
      throw new Error("transport is null, please pass in a valid RPC Provider URL as the transport.");
    }
    var clientConfig = {
      chain: chainStringToViemChain(this.config.chainId || "sepolia"),
      transport: this.config.transport
    };
    this.rpcClient = createPublicClient(clientConfig);
    this.storyClient = new StoryAPIClient();
    var account = this.config.account;
    if (!account) {
      throw new Error("account is null");
    }
    this.wallet = createWalletClient(_objectSpread2(_objectSpread2({}, clientConfig), {}, {
      account: account
    }));
  }

  /**
   * Factory method for creating a SDK client with a signer.
   *
   * @param config - the configuration for a new SDK client
   */
  _createClass(StoryClient, [{
    key: "ipAsset",
    get:
    /**
     * Getter for the ip asset client. The client is lazily created when
     * this method is called.
     *
     * @returns the IPAssetClient instance
     */
    function get() {
      if (this._ipAsset === null) {
        this._ipAsset = new IPAssetClient(this.rpcClient, this.wallet, this.storyClient);
      }
      return this._ipAsset;
    }

    /**
     * Getter for the permission client. The client is lazily created when
     * this method is called.
     *
     * @returns the PermissionClient instance
     */
  }, {
    key: "permission",
    get: function get() {
      if (this._permission === null) {
        this._permission = new PermissionClient(this.rpcClient, this.wallet);
      }
      return this._permission;
    }

    /**
     * Getter for the license client. The client is lazily created when
     * this method is called.
     *
     * @returns the LicenseClient instance
     */
  }, {
    key: "license",
    get: function get() {
      if (this._license === null) {
        this._license = new LicenseClient(this.rpcClient, this.wallet, this.storyClient);
      }
      return this._license;
    }

    /**
     * Getter for the policy client. The client is lazily created when
     * this method is called.
     *
     * @returns the PolicyClient instance
     */
  }, {
    key: "policy",
    get: function get() {
      if (this._policy === null) {
        this._policy = new PolicyClient(this.rpcClient, this.wallet);
      }
      return this._policy;
    }

    /**
     * Getter for the dispute client. The client is lazily created when
     * this method is called.
     *
     * @returns the DisputeClient instance
     */
  }, {
    key: "dispute",
    get: function get() {
      if (this._dispute === null) {
        this._dispute = new DisputeClient(this.rpcClient, this.wallet);
      }
      return this._dispute;
    }

    /**
     * Getter for the ip account client. The client is lazily created when
     * this method is called.
     *
     * @returns the IPAccountClient instance
     */
  }, {
    key: "ipAccount",
    get: function get() {
      if (this._ipAccount === null) {
        this._ipAccount = new IPAccountClient(this.rpcClient, this.wallet);
      }
      return this._ipAccount;
    }
  }], [{
    key: "newClient",
    value: function newClient(config) {
      return new StoryClient(config);
    }
  }]);
  return StoryClient;
}();

export { AddressZero, DisputeClient, HashZero, IPAssetClient, LicenseClient, PermissionClient, PolicyClient, StoryClient };
